---- rx_indicate Matches (53 in 30 files) ----
at_cli_init in at_cli.c (rt-thread\components\net\at\src) : 
        /* backup RX indicate */
        odev_rx_ind = console->rx_indicate;
        rt_device_set_rx_indicate(console, console_getchar_rx_ind);
    }

client_cli_parser in at_cli.c (rt-thread\components\net\at\src) : 
            int_lvl = rt_hw_interrupt_disable();
            client_odev_rx_ind = client->device->rx_indicate;
            rt_device_set_rx_indicate(client->device, client_getchar_rx_ind);
            rt_hw_interrupt_enable(int_lvl);
        }
pppos_output_cb in at_socket_sim800c.c (packages\at_device-latest) : 
{
	if (at_client_get_first()->device->rx_indicate != pppos_rx_ind)
		return 0;

  	return sio_write((void *)(at_client_get_first()->device), data, len);
pppos_init in at_socket_sim800c.c (packages\at_device-latest) : 
	pppos_rcv_cnt = 0x8000;	
	at_client_rx_ind = at_client_get_first()->device->rx_indicate;
    rt_device_set_rx_indicate(at_client_get_first()->device, pppos_rx_ind);     
	pppos_rcv_cnt = 0;	
	
sim800c_get_signal_strength in at_socket_sim800c.c (packages\at_device-latest) : 
		pppos_rcv_cnt = 0x8000;
		at_client_rx_ind = at_client_get_first()->device->rx_indicate;
    	rt_device_set_rx_indicate(at_client_get_first()->device, pppos_rx_ind);
		pppos_rcv_cnt = 0;
	}
rt_audio_register in audio.c (rt-thread\components\drivers\audio) : 
    device->type = RT_Device_Class_Sound;
    device->rx_indicate = RT_NULL;
    device->tx_complete = RT_NULL;

#ifdef RT_USING_DEVICE_OPS
rt_audio_rx_done in audio.c (rt-thread\components\drivers\audio) : 
    /* invoke callback */
    if (audio->parent.rx_indicate != RT_NULL)
        audio->parent.rx_indicate(&audio->parent, len);
}

_rt_pipe_resume_reader in audio_pipe.c (rt-thread\components\drivers\audio) : 
{
    if (pipe->parent.rx_indicate)
        pipe->parent.rx_indicate(&pipe->parent,
                                 rt_ringbuffer_data_len(&pipe->ringbuffer));

    if (!rt_list_isempty(&pipe->suspended_read_list))
rt_hw_can_register in can.c (rt-thread\components\drivers\can) : 
    device->type        = RT_Device_Class_CAN;
    device->rx_indicate = RT_NULL;
    device->tx_complete = RT_NULL;
#ifdef RT_CAN_USING_HDR
    can->hdr            = RT_NULL;
rt_hw_can_isr in can.c (rt-thread\components\drivers\can) : 
        {
            if (can->parent.rx_indicate != RT_NULL)
            {
                rt_size_t rx_length;

rt_hw_can_isr in can.c (rt-thread\components\drivers\can) : 

                can->parent.rx_indicate(&can->parent, rx_length);
            }
        }
        break;
_ep0_out_notify in core.c (rt-thread\components\drivers\usb\usbdevice\core) : 
        /* invoke callback */
        if(ep0->rx_indicate != RT_NULL)
        {
            ep0->rx_indicate(device, size);
        }        
    }
    else
    {
        rt_usbd_ep0_read(device, ep0->request.buffer, ep0->request.remain_size,ep0->rx_indicate);
    }

    return RT_EOK;
rt_usbd_ep0_read in core.c (rt-thread\components\drivers\usb\usbdevice\core) : 
    ep0->request.remain_size = size;
    ep0->rx_indicate = rx_ind;
    if(size >= ep0->id->maxpacket)
    {
        read_size = ep0->id->maxpacket;
rt_device_set_rx_indicate in device.c (rt-thread\src) : 

    dev->rx_indicate = rx_ind;

    return RT_EOK;
}
rt_hw_rtc_init in drv_rtc.c (drivers) : 
    rtc_device.type        = RT_Device_Class_RTC;
    rtc_device.rx_indicate = RT_NULL;
    rtc_device.tx_complete = RT_NULL;
    rtc_device.init        = stm32_rtc_init;
    rtc_device.open        = stm32_rtc_open;
rt_hwtimer_close in hwtimer.c (rt-thread\components\drivers\hwtimer) : 
    dev->flag &= ~RT_DEVICE_FLAG_ACTIVATED;
    dev->rx_indicate = RT_NULL;

    return result;
}
rt_device_hwtimer_isr in hwtimer.c (rt-thread\components\drivers\hwtimer) : 

        if (timer->parent.rx_indicate != RT_NULL)
        {
            timer->parent.rx_indicate(&timer->parent, sizeof(struct rt_hwtimerval));
        }
    }
}
rt_device_hwtimer_register in hwtimer.c (rt-thread\components\drivers\hwtimer) : 
    device->type        = RT_Device_Class_Timer;
    device->rx_indicate = RT_NULL;
    device->tx_complete = RT_NULL;

#ifdef RT_USING_DEVICE_OPS
log_trace_init in log_trace.c (rt-thread\components\utilities\logtrace) : 
    /* no indication and complete callback */
    _log_device.rx_indicate = RT_NULL;
    _log_device.tx_complete = RT_NULL;

    rt_device_register(&_log_device, "log", RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_RDWR);
main.c (applications) line 167 : 
    
    client_odev_rx_ind = sio_dev->rx_indicate;
    rt_device_set_rx_indicate(sio_dev, RT_NULL);
        
    ppp_set_default(ppp);
rt_mtd_nand_register_device in mtd_nand.c (rt-thread\components\drivers\mtd) : 

    dev->rx_indicate = RT_NULL;
    dev->tx_complete = RT_NULL;

    /* register to RT-Thread device system */
rt_mtd_nor_register_device in mtd_nor.c (rt-thread\components\drivers\mtd) : 

    dev->rx_indicate = RT_NULL;
    dev->tx_complete = RT_NULL;

    /* register to RT-Thread device system */
rt_device_pin_register in pin.c (rt-thread\components\drivers\misc) : 
    _hw_pin.parent.type         = RT_Device_Class_Miscellaneous;
    _hw_pin.parent.rx_indicate  = RT_NULL;
    _hw_pin.parent.tx_complete  = RT_NULL;

#ifdef RT_USING_DEVICE_OPS
rt_pipe_create in pipe.c (rt-thread\components\drivers\src) : 

    dev->rx_indicate = RT_NULL;
    dev->tx_complete = RT_NULL;

    if (rt_device_register(&(pipe->parent), name, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_REMOVABLE) != 0)
rt_system_pm_init in pm.c (rt-thread\components\drivers\pm) : 
    device->type        = RT_Device_Class_PM;
    device->rx_indicate = RT_NULL;
    device->tx_complete = RT_NULL;

    device->init        = RT_NULL;
rt_device in rtdef.h (rt-thread\include) : 
    /* device call back */
    rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size);
    rt_err_t (*tx_complete)(rt_device_t dev, void *buffer);

#ifdef RT_USING_DEVICE_OPS
rt_sensor_cb in sensor.c (rt-thread\components\drivers\sensors) : 
{
    if (sen->parent.rx_indicate == RT_NULL)
    {
        return;
    }
rt_sensor_cb in sensor.c (rt-thread\components\drivers\sensors) : 
    {
        sen->parent.rx_indicate(&sen->parent, sen->data_len / sizeof(struct rt_sensor_data));
    }
    else if (sen->config.mode == RT_SENSOR_MODE_INT)
    {
        /* The interrupt mode only produces one data at a time */
        sen->parent.rx_indicate(&sen->parent, 1);
    }
    else if (sen->config.mode == RT_SENSOR_MODE_FIFO)
    {
        sen->parent.rx_indicate(&sen->parent, sen->info.fifo_max);
    }
}

rt_hw_sensor_register in sensor.c (rt-thread\components\drivers\sensors) : 
    device->type        = RT_Device_Class_Sensor;
    device->rx_indicate = RT_NULL;
    device->tx_complete = RT_NULL;
    device->user_data   = data;

rt_hw_serial_register in serial.c (rt-thread\components\drivers\serial) : 
    device->type        = RT_Device_Class_Char;
    device->rx_indicate = RT_NULL;
    device->tx_complete = RT_NULL;

#ifdef RT_USING_DEVICE_OPS
rt_hw_serial_isr in serial.c (rt-thread\components\drivers\serial) : 
            /* invoke callback */
            if (serial->parent.rx_indicate != RT_NULL)
            {
                rt_size_t rx_length;

rt_hw_serial_isr in serial.c (rt-thread\components\drivers\serial) : 
                {
                    serial->parent.rx_indicate(&serial->parent, rx_length);
                }
            }
            break;
rt_hw_serial_isr in serial.c (rt-thread\components\drivers\serial) : 

                RT_ASSERT(serial->parent.rx_indicate != RT_NULL);
                serial->parent.rx_indicate(&(serial->parent), length);
                rx_dma->activated = RT_FALSE;
            }
            else
rt_hw_serial_isr in serial.c (rt-thread\components\drivers\serial) : 
                /* invoke callback */
                if (serial->parent.rx_indicate != RT_NULL)
                {
                    serial->parent.rx_indicate(&(serial->parent), length);
                }
            }
            break;
rt_hw_serial_isr in serial.c (rt-thread\libcpu\arm\AT91SAM7S) : 
	/* indicate to upper layer application */
	if (device->rx_indicate != RT_NULL)
		device->rx_indicate(device, 1);

	/* ack interrupt */
	AT91C_AIC_EOICR = 1;
rt_hw_serial_register in serial.c (rt-thread\libcpu\arm\s3c24x0) : 
    device->type        = RT_Device_Class_Char;
    device->rx_indicate = RT_NULL;
    device->tx_complete = RT_NULL;
    device->init        = rt_serial_init;
    device->open        = rt_serial_open;
rt_hw_serial_isr in serial.c (rt-thread\libcpu\arm\s3c24x0) : 
    /* invoke callback */
    if (device->rx_indicate != RT_NULL)
    {
        rt_size_t rx_length;

rt_hw_serial_isr in serial.c (rt-thread\libcpu\arm\s3c24x0) : 

        device->rx_indicate(device, rx_length);
    }
}

/*@}*/
rt_hw_serial_register in serial.c (rt-thread\libcpu\arm\sep4020) : 
	device->type 		= RT_Device_Class_Char;
	device->rx_indicate = RT_NULL;
	device->tx_complete = RT_NULL;
	device->init 		= rt_serial_init;
	device->open		= rt_serial_open;
rt_hw_serial_isr in serial.c (rt-thread\libcpu\arm\sep4020) : 
	/* invoke callback */
	if (device->rx_indicate != RT_NULL)
	{
		rt_size_t rx_length;
		
rt_hw_serial_isr in serial.c (rt-thread\libcpu\arm\sep4020) : 

		device->rx_indicate(device, rx_length);
	}
}

msd_init in spi_msd.c (rt-thread\components\drivers\spi) : 
    _msd_device.parent.user_data = RT_NULL;
    _msd_device.parent.rx_indicate = RT_NULL;
    _msd_device.parent.tx_complete = RT_NULL;

    result = rt_device_register(&_msd_device.parent, sd_device_name,
process_rx in telnet.c (packages\netutils-latest\telnet) : 
    /* indicate there are reception data */
    if ((rx_length > 0) && (telnet->device.rx_indicate != RT_NULL))
    {
        telnet->device.rx_indicate(&telnet->device, rx_length);
    }
#endif

uendpoint in usb_device.h (rt-thread\components\drivers\include\drivers) : 
    udep_handler_t handler;
    rt_err_t (*rx_indicate)(struct udevice* dev, rt_size_t size);
};
typedef struct uendpoint* uep_t;

_rx_indicate in vbus_chnx.c (rt-thread\components\vbus) : 

    if (dev->rx_indicate)
        dev->rx_indicate(dev, 0);
}

static void _tx_complete(void *ctx)
_read in vbus_chnx.c (rt-thread\components\vbus) : 

        /* TODO: We don't want to touch the rx_indicate here. But this lead to
         * some duplication. Maybe we should find a better way to handle this.
         */
        if (rt_interrupt_get_nest() == 0)
rt_hw_watchdog_register in watchdog.c (rt-thread\components\drivers\watchdog) : 
    device->type        = RT_Device_Class_Miscellaneous;
    device->rx_indicate = RT_NULL;
    device->tx_complete = RT_NULL;

#ifdef RT_USING_DEVICE_OPS
_ep_out_handler in winusb.c (rt-thread\components\drivers\usb\usbdevice\class) : 
    winusb_device_t winusb_device = (winusb_device_t)func->user_data;
    if(winusb_device->parent.rx_indicate != RT_NULL)
    {
        winusb_device->parent.rx_indicate(&winusb_device->parent, size);
    }
    return RT_EOK;
}
rym_recv_on_device in ymodem.c (rt-thread\components\utilities\ymodem) : 

    odev_rx_ind = dev->rx_indicate;
    /* no data should be received before the device has been fully setted up.
     */
    int_lvl = rt_hw_interrupt_disable();
finsh_rz in zstart.c (rt-thread\components\utilities\zmodem) : 
	char *path;
    rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size);
    rt_uint8_t flag;	

	flag = RT_DEVICE_FLAG_STREAM;
finsh_rz in zstart.c (rt-thread\components\utilities\zmodem) : 
	path = rt_thread_self()->parameter;
    /* save old rx_indicate	*/
    rx_indicate = zmodem.device->rx_indicate;
    /* set new rx_indicate */
    rt_device_set_rx_indicate(zmodem.device, RT_NULL);
	/* start receive remote files */
    zr_start(path);
	zmodem.device->flag |=flag;
    /* recovery old rx_indicate	*/
    rt_device_set_rx_indicate(zmodem.device, rx_indicate);
    /* finsh>> */
    rt_kprintf(FINSH_PROMPT);
}
finsh_sz in zstart.c (rt-thread\components\utilities\zmodem) : 
	char *path;
    rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size);
    rt_uint8_t flag;	

	flag = RT_DEVICE_FLAG_STREAM;
finsh_sz in zstart.c (rt-thread\components\utilities\zmodem) : 
	path = rt_thread_self()->parameter;
	/* save old rx_indicate	*/
    rx_indicate = zmodem.device->rx_indicate;
	/* set new rx_indicate */
    rt_device_set_rx_indicate(zmodem.device, zmodem_rx_ind);
	zs_start(path);
	zmodem.device->flag |=flag;
    /* recovery old rx_indicate	*/
    rt_device_set_rx_indicate(zmodem.device, rx_indicate);
    /* finsh>> */
    rt_kprintf(FINSH_PROMPT);
}
